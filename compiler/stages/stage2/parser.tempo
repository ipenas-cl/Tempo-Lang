// â•”â•â•â•â•â•â•¦â•â•â•â•â•â•¦â•â•â•â•â•â•—
// â•‘ ğŸ›¡ï¸  â•‘ âš–ï¸  â•‘ âš¡  â•‘
// â•‘  C  â•‘  E  â•‘  G  â•‘
// â•šâ•â•â•â•â•â•©â•â•â•â•â•â•©â•â•â•â•â•â•
// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘ wcet [Tâˆ] bound â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Author: Ignacio PeÃ±a SepÃºlveda
// Date: June 25, 2025

// ===========================================================================
// TEMPO COMPILER STAGE 2 - PARSER
// ===========================================================================
// Full recursive descent parser with error recovery and incremental parsing
// ===========================================================================

import "lexer.tempo"
import "ast.tempo"
import "types.tempo"
import "errors.tempo"

// ===========================================================================
// Parser state and configuration
// ===========================================================================

type Parser = {
    lexer: Lexer,
    current: Token,
    previous: Token,
    errors: Vec<ParseError>,
    panic_mode: bool,
    synchronize_points: Vec<TokenType>,
    
    // For incremental parsing
    checkpoint_stack: Vec<ParserCheckpoint>,
    modified_ranges: Vec<Range>,
    
    // For better error messages
    context_stack: Vec<ParseContext>,
    
    // Recovery strategies
    recovery_tokens: Set<TokenType>,
}

type ParseError = {
    message: String,
    span: Span,
    context: Vec<String>,
    suggestions: Vec<String>,
}

type ParserCheckpoint = {
    position: u32,
    token: Token,
    errors_count: usize,
}

type Range = {
    start: u32,
    end: u32,
}

enum ParseContext {
    Function(String),
    Type(String),
    Trait(String),
    Impl,
    Block,
    Expression,
    Pattern,
    Statement,
}

// ===========================================================================
// Parser initialization
// ===========================================================================

function new_parser(source: string, file_id: u32) -> Parser {
    let mut lexer = new_lexer(source, file_id);
    let current = next_token(&mut lexer);
    
    let mut recovery_tokens = Set::new();
    recovery_tokens.insert(TokenType::SEMICOLON);
    recovery_tokens.insert(TokenType::RBRACE);
    recovery_tokens.insert(TokenType::FUNCTION);
    recovery_tokens.insert(TokenType::TYPE);
    recovery_tokens.insert(TokenType::TRAIT);
    recovery_tokens.insert(TokenType::IMPL);
    recovery_tokens.insert(TokenType::LET);
    
    Parser {
        lexer,
        current,
        previous: Token { 
            type: TokenType::EOF, 
            value: String::new(), 
            line: 0, 
            column: 0,
            span: Span { start: 0, end: 0, file_id }
        },
        errors: Vec::new(),
        panic_mode: false,
        synchronize_points: vec![
            TokenType::SEMICOLON,
            TokenType::RBRACE,
            TokenType::FUNCTION,
            TokenType::TYPE,
            TokenType::TRAIT,
            TokenType::IMPL,
        ],
        checkpoint_stack: Vec::new(),
        modified_ranges: Vec::new(),
        context_stack: Vec::new(),
        recovery_tokens,
    }
}

// ===========================================================================
// Main parsing functions
// ===========================================================================

function parse_program(parser: &mut Parser) -> Result<Program, Vec<ParseError>> {
    let mut program = new_program();
    
    // Parse module
    let module = parse_module(parser)?;
    program.modules.push(module);
    
    if !parser.errors.is_empty() {
        return Err(parser.errors.clone());
    }
    
    Ok(program)
}

function parse_module(parser: &mut Parser) -> Result<Module, ()> {
    let start_span = parser.current.span;
    let mut imports = Vec::new();
    let mut exports = Vec::new();
    let mut items = Vec::new();
    
    // Parse imports
    while check(parser, TokenType::IMPORT) {
        match parse_import(parser) {
            Ok(import) => imports.push(import),
            Err(_) => synchronize(parser),
        }
    }
    
    // Parse exports
    while check(parser, TokenType::EXPORT) {
        match parse_export(parser) {
            Ok(export) => exports.push(export),
            Err(_) => synchronize(parser),
        }
    }
    
    // Parse items
    while !is_at_end(parser) {
        match parse_item(parser) {
            Ok(item) => items.push(item),
            Err(_) => synchronize(parser),
        }
    }
    
    Ok(Module {
        name: String::from("main"),
        imports,
        exports,
        items,
        span: span_union(start_span, parser.previous.span),
    })
}

// ===========================================================================
// Import/Export parsing
// ===========================================================================

function parse_import(parser: &mut Parser) -> Result<Import, ()> {
    let start_span = consume(parser, TokenType::IMPORT, "Expected 'import'")?;
    let path = consume_string(parser, "Expected import path")?;
    
    let items = if match_token(parser, TokenType::LBRACE) {
        let mut specific = Vec::new();
        
        if !check(parser, TokenType::RBRACE) {
            loop {
                specific.push(consume_identifier(parser, "Expected identifier")?);
                if !match_token(parser, TokenType::COMMA) {
                    break;
                }
            }
        }
        
        consume(parser, TokenType::RBRACE, "Expected '}'")?;
        ImportItems::Specific(specific)
    } else {
        ImportItems::All
    };
    
    let alias = if match_token(parser, TokenType::IDENTIFIER) && parser.previous.value == "as" {
        Some(consume_identifier(parser, "Expected alias")?)
    } else {
        None
    };
    
    consume(parser, TokenType::SEMICOLON, "Expected ';'")?;
    
    Ok(Import {
        path,
        items,
        alias,
        span: span_union(start_span, parser.previous.span),
    })
}

function parse_export(parser: &mut Parser) -> Result<Export, ()> {
    let start_span = consume(parser, TokenType::EXPORT, "Expected 'export'")?;
    let item = consume_identifier(parser, "Expected item to export")?;
    
    let alias = if match_token(parser, TokenType::IDENTIFIER) && parser.previous.value == "as" {
        Some(consume_identifier(parser, "Expected alias")?)
    } else {
        None
    };
    
    consume(parser, TokenType::SEMICOLON, "Expected ';'")?;
    
    Ok(Export {
        item,
        alias,
        span: span_union(start_span, parser.previous.span),
    })
}

// ===========================================================================
// Item parsing
// ===========================================================================

function parse_item(parser: &mut Parser) -> Result<Item, ()> {
    // Parse attributes
    let attributes = parse_attributes(parser)?;
    
    // Parse visibility
    let visibility = parse_visibility(parser)?;
    
    // Parse item based on keyword
    if check(parser, TokenType::FUNCTION) {
        Ok(Item::Function(parse_function(parser, attributes, visibility)?))
    } else if check(parser, TokenType::TYPE) {
        Ok(Item::Type(parse_type_decl(parser, visibility)?))
    } else if check(parser, TokenType::ENUM) {
        Ok(Item::Enum(parse_enum(parser, visibility)?))
    } else if check(parser, TokenType::TRAIT) {
        Ok(Item::Trait(parse_trait(parser, visibility)?))
    } else if check(parser, TokenType::IMPL) {
        Ok(Item::Impl(parse_impl(parser)?))
    } else if check(parser, TokenType::CONST) {
        Ok(Item::Const(parse_const(parser, visibility)?))
    } else if check(parser, TokenType::STATIC) {
        Ok(Item::Static(parse_static(parser, visibility)?))
    } else {
        error(parser, "Expected item declaration");
        Err(())
    }
}

// ===========================================================================
// Function parsing
// ===========================================================================

function parse_function(
    parser: &mut Parser, 
    attributes: Vec<Attribute>,
    visibility: Visibility
) -> Result<FunctionDecl, ()> {
    let start_span = consume(parser, TokenType::FUNCTION, "Expected 'function'")?;
    push_context(parser, ParseContext::Function(parser.current.value.clone()));
    
    let name = consume_identifier(parser, "Expected function name")?;
    
    // Parse generics
    let generics = if check(parser, TokenType::LESS_THAN) {
        Some(parse_generic_params(parser)?)
    } else {
        None
    };
    
    // Parse parameters
    consume(parser, TokenType::LPAREN, "Expected '('")?;
    let params = parse_parameters(parser)?;
    consume(parser, TokenType::RPAREN, "Expected ')'")?;
    
    // Parse return type
    let return_type = if match_token(parser, TokenType::ARROW) {
        Some(parse_type_expr(parser)?)
    } else {
        None
    };
    
    // Parse WCET annotation
    let wcet = if match_token(parser, TokenType::WITHIN) {
        Some(parse_wcet_annotation(parser)?)
    } else {
        None
    };
    
    // Parse body
    let body = if check(parser, TokenType::LBRACE) {
        Some(parse_block(parser)?)
    } else {
        consume(parser, TokenType::SEMICOLON, "Expected ';' or function body")?;
        None
    };
    
    pop_context(parser);
    
    Ok(FunctionDecl {
        name,
        generics,
        params,
        return_type,
        body,
        attributes,
        visibility,
        is_async: false, // TODO: Parse async
        wcet,
        span: span_union(start_span, parser.previous.span),
    })
}

function parse_parameters(parser: &mut Parser) -> Result<Vec<Parameter>, ()> {
    let mut params = Vec::new();
    
    if !check(parser, TokenType::RPAREN) {
        loop {
            params.push(parse_parameter(parser)?);
            if !match_token(parser, TokenType::COMMA) {
                break;
            }
        }
    }
    
    Ok(params)
}

function parse_parameter(parser: &mut Parser) -> Result<Parameter, ()> {
    let start_span = parser.current.span;
    let pattern = parse_pattern(parser)?;
    consume(parser, TokenType::COLON, "Expected ':'")?;
    let type_expr = parse_type_expr(parser)?;
    
    let default = if match_token(parser, TokenType::EQUALS) {
        Some(parse_expression(parser)?)
    } else {
        None
    };
    
    Ok(Parameter {
        pattern,
        type: type_expr,
        default,
        span: span_union(start_span, parser.previous.span),
    })
}

// ===========================================================================
// Type declaration parsing
// ===========================================================================

function parse_type_decl(parser: &mut Parser, visibility: Visibility) -> Result<TypeDecl, ()> {
    let start_span = consume(parser, TokenType::TYPE, "Expected 'type'")?;
    let name = consume_identifier(parser, "Expected type name")?;
    
    push_context(parser, ParseContext::Type(name.clone()));
    
    let generics = if check(parser, TokenType::LESS_THAN) {
        Some(parse_generic_params(parser)?)
    } else {
        None
    };
    
    consume(parser, TokenType::EQUALS, "Expected '='")?;
    
    let definition = if match_token(parser, TokenType::LBRACE) {
        TypeDefinition::Struct(parse_struct_def(parser)?)
    } else if match_token(parser, TokenType::IDENTIFIER) && parser.previous.value == "union" {
        consume(parser, TokenType::LBRACE, "Expected '{'")?;
        TypeDefinition::Union(parse_union_def(parser)?)
    } else {
        TypeDefinition::Alias(parse_type_expr(parser)?)
    };
    
    if !matches!(definition, TypeDefinition::Alias(_)) {
        consume(parser, TokenType::SEMICOLON, "Expected ';'")?;
    }
    
    pop_context(parser);
    
    Ok(TypeDecl {
        name,
        generics,
        definition,
        visibility,
        span: span_union(start_span, parser.previous.span),
    })
}

function parse_struct_def(parser: &mut Parser) -> Result<StructDef, ()> {
    let mut fields = Vec::new();
    let mut is_packed = false;
    
    // Check for packed attribute
    if check(parser, TokenType::HASH) {
        let attrs = parse_attributes(parser)?;
        for attr in attrs {
            if attr.name == "packed" {
                is_packed = true;
            }
        }
    }
    
    while !check(parser, TokenType::RBRACE) {
        fields.push(parse_field_def(parser)?);
        if !match_token(parser, TokenType::COMMA) && !check(parser, TokenType::RBRACE) {
            error(parser, "Expected ',' or '}'");
            synchronize_until(parser, &[TokenType::COMMA, TokenType::RBRACE]);
        }
    }
    
    consume(parser, TokenType::RBRACE, "Expected '}'")?;
    
    Ok(StructDef { fields, is_packed })
}

function parse_field_def(parser: &mut Parser) -> Result<FieldDef, ()> {
    let start_span = parser.current.span;
    let visibility = parse_visibility(parser)?;
    let name = consume_identifier(parser, "Expected field name")?;
    consume(parser, TokenType::COLON, "Expected ':'")?;
    let type_expr = parse_type_expr(parser)?;
    
    Ok(FieldDef {
        name,
        type: type_expr,
        visibility,
        attributes: Vec::new(),
        span: span_union(start_span, parser.previous.span),
    })
}

// ===========================================================================
// Enum parsing
// ===========================================================================

function parse_enum(parser: &mut Parser, visibility: Visibility) -> Result<EnumDecl, ()> {
    let start_span = consume(parser, TokenType::ENUM, "Expected 'enum'")?;
    let name = consume_identifier(parser, "Expected enum name")?;
    
    let generics = if check(parser, TokenType::LESS_THAN) {
        Some(parse_generic_params(parser)?)
    } else {
        None
    };
    
    consume(parser, TokenType::LBRACE, "Expected '{'")?;
    
    let mut variants = Vec::new();
    while !check(parser, TokenType::RBRACE) {
        variants.push(parse_enum_variant(parser)?);
        if !match_token(parser, TokenType::COMMA) && !check(parser, TokenType::RBRACE) {
            error(parser, "Expected ',' or '}'");
        }
    }
    
    consume(parser, TokenType::RBRACE, "Expected '}'")?;
    
    Ok(EnumDecl {
        name,
        generics,
        variants,
        visibility,
        span: span_union(start_span, parser.previous.span),
    })
}

function parse_enum_variant(parser: &mut Parser) -> Result<EnumVariant, ()> {
    let start_span = parser.current.span;
    let attributes = parse_attributes(parser)?;
    let name = consume_identifier(parser, "Expected variant name")?;
    
    let fields = if match_token(parser, TokenType::LPAREN) {
        // Tuple variant
        let mut types = Vec::new();
        if !check(parser, TokenType::RPAREN) {
            loop {
                types.push(parse_type_expr(parser)?);
                if !match_token(parser, TokenType::COMMA) {
                    break;
                }
            }
        }
        consume(parser, TokenType::RPAREN, "Expected ')'")?;
        VariantFields::Tuple(types)
    } else if match_token(parser, TokenType::LBRACE) {
        // Struct variant
        let mut fields = Vec::new();
        while !check(parser, TokenType::RBRACE) {
            fields.push(parse_field_def(parser)?);
            if !match_token(parser, TokenType::COMMA) && !check(parser, TokenType::RBRACE) {
                error(parser, "Expected ',' or '}'");
            }
        }
        consume(parser, TokenType::RBRACE, "Expected '}'")?;
        VariantFields::Struct(fields)
    } else {
        // Unit variant
        VariantFields::Unit
    };
    
    let discriminant = if match_token(parser, TokenType::EQUALS) {
        Some(parse_expression(parser)?)
    } else {
        None
    };
    
    Ok(EnumVariant {
        name,
        fields,
        discriminant,
        attributes,
        span: span_union(start_span, parser.previous.span),
    })
}

// ===========================================================================
// Trait parsing
// ===========================================================================

function parse_trait(parser: &mut Parser, visibility: Visibility) -> Result<TraitDecl, ()> {
    let start_span = consume(parser, TokenType::TRAIT, "Expected 'trait'")?;
    let name = consume_identifier(parser, "Expected trait name")?;
    
    push_context(parser, ParseContext::Trait(name.clone()));
    
    let generics = if check(parser, TokenType::LESS_THAN) {
        Some(parse_generic_params(parser)?)
    } else {
        None
    };
    
    let bounds = if match_token(parser, TokenType::COLON) {
        parse_trait_bounds(parser)?
    } else {
        Vec::new()
    };
    
    consume(parser, TokenType::LBRACE, "Expected '{'")?;
    
    let mut items = Vec::new();
    while !check(parser, TokenType::RBRACE) {
        items.push(parse_trait_item(parser)?);
    }
    
    consume(parser, TokenType::RBRACE, "Expected '}'")?;
    
    pop_context(parser);
    
    Ok(TraitDecl {
        name,
        generics,
        bounds,
        items,
        visibility,
        span: span_union(start_span, parser.previous.span),
    })
}

function parse_trait_item(parser: &mut Parser) -> Result<TraitItem, ()> {
    if check(parser, TokenType::FUNCTION) {
        Ok(TraitItem::Method(parse_method_signature(parser)?))
    } else if check(parser, TokenType::TYPE) {
        Ok(TraitItem::AssociatedType(parse_associated_type(parser)?))
    } else if check(parser, TokenType::CONST) {
        Ok(TraitItem::Const(parse_const(parser, Visibility::Public)?))
    } else {
        error(parser, "Expected trait item");
        Err(())
    }
}

// ===========================================================================
// Expression parsing
// ===========================================================================

function parse_expression(parser: &mut Parser) -> Result<Expression, ()> {
    push_context(parser, ParseContext::Expression);
    let result = parse_assignment(parser);
    pop_context(parser);
    result
}

function parse_assignment(parser: &mut Parser) -> Result<Expression, ()> {
    let expr = parse_logical_or(parser)?;
    
    if match_token(parser, TokenType::EQUALS) {
        let value = parse_assignment(parser)?;
        if !is_lvalue(&expr) {
            error(parser, "Invalid assignment target");
        }
        return Ok(Expression::Assignment(Box::new(expr), Box::new(value)));
    }
    
    // Compound assignments
    let op = if match_token(parser, TokenType::PLUS_EQUALS) {
        Some(BinaryOp::Add)
    } else if match_token(parser, TokenType::MINUS_EQUALS) {
        Some(BinaryOp::Sub)
    } else if match_token(parser, TokenType::STAR_EQUALS) {
        Some(BinaryOp::Mul)
    } else if match_token(parser, TokenType::SLASH_EQUALS) {
        Some(BinaryOp::Div)
    } else if match_token(parser, TokenType::PERCENT_EQUALS) {
        Some(BinaryOp::Rem)
    } else {
        None
    };
    
    if let Some(op) = op {
        let value = parse_assignment(parser)?;
        if !is_lvalue(&expr) {
            error(parser, "Invalid assignment target");
        }
        return Ok(Expression::CompoundAssignment(op, Box::new(expr), Box::new(value)));
    }
    
    Ok(expr)
}

function parse_logical_or(parser: &mut Parser) -> Result<Expression, ()> {
    let mut expr = parse_logical_and(parser)?;
    
    while match_token(parser, TokenType::DOUBLE_PIPE) {
        let right = parse_logical_and(parser)?;
        expr = Expression::Binary(BinaryOp::Or, Box::new(expr), Box::new(right));
    }
    
    Ok(expr)
}

function parse_logical_and(parser: &mut Parser) -> Result<Expression, ()> {
    let mut expr = parse_equality(parser)?;
    
    while match_token(parser, TokenType::DOUBLE_AMPERSAND) {
        let right = parse_equality(parser)?;
        expr = Expression::Binary(BinaryOp::And, Box::new(expr), Box::new(right));
    }
    
    Ok(expr)
}

function parse_equality(parser: &mut Parser) -> Result<Expression, ()> {
    let mut expr = parse_comparison(parser)?;
    
    while let Some(op) = match parser.current.type {
        TokenType::DOUBLE_EQUALS => { advance(parser); Some(BinaryOp::Eq) }
        TokenType::NOT_EQUALS => { advance(parser); Some(BinaryOp::Ne) }
        _ => None
    } {
        let right = parse_comparison(parser)?;
        expr = Expression::Binary(op, Box::new(expr), Box::new(right));
    }
    
    Ok(expr)
}

function parse_comparison(parser: &mut Parser) -> Result<Expression, ()> {
    let mut expr = parse_bitwise_or(parser)?;
    
    while let Some(op) = match parser.current.type {
        TokenType::LESS_THAN => { advance(parser); Some(BinaryOp::Lt) }
        TokenType::LESS_EQUALS => { advance(parser); Some(BinaryOp::Le) }
        TokenType::GREATER_THAN => { advance(parser); Some(BinaryOp::Gt) }
        TokenType::GREATER_EQUALS => { advance(parser); Some(BinaryOp::Ge) }
        _ => None
    } {
        let right = parse_bitwise_or(parser)?;
        expr = Expression::Binary(op, Box::new(expr), Box::new(right));
    }
    
    Ok(expr)
}

function parse_bitwise_or(parser: &mut Parser) -> Result<Expression, ()> {
    let mut expr = parse_bitwise_xor(parser)?;
    
    while match_token(parser, TokenType::PIPE) {
        let right = parse_bitwise_xor(parser)?;
        expr = Expression::Binary(BinaryOp::BitOr, Box::new(expr), Box::new(right));
    }
    
    Ok(expr)
}

function parse_bitwise_xor(parser: &mut Parser) -> Result<Expression, ()> {
    let mut expr = parse_bitwise_and(parser)?;
    
    while match_token(parser, TokenType::CARET) {
        let right = parse_bitwise_and(parser)?;
        expr = Expression::Binary(BinaryOp::BitXor, Box::new(expr), Box::new(right));
    }
    
    Ok(expr)
}

function parse_bitwise_and(parser: &mut Parser) -> Result<Expression, ()> {
    let mut expr = parse_shift(parser)?;
    
    while match_token(parser, TokenType::AMPERSAND) {
        let right = parse_shift(parser)?;
        expr = Expression::Binary(BinaryOp::BitAnd, Box::new(expr), Box::new(right));
    }
    
    Ok(expr)
}

function parse_shift(parser: &mut Parser) -> Result<Expression, ()> {
    let mut expr = parse_additive(parser)?;
    
    while let Some(op) = match parser.current.type {
        TokenType::LEFT_SHIFT => { advance(parser); Some(BinaryOp::Shl) }
        TokenType::RIGHT_SHIFT => { advance(parser); Some(BinaryOp::Shr) }
        _ => None
    } {
        let right = parse_additive(parser)?;
        expr = Expression::Binary(op, Box::new(expr), Box::new(right));
    }
    
    Ok(expr)
}

function parse_additive(parser: &mut Parser) -> Result<Expression, ()> {
    let mut expr = parse_multiplicative(parser)?;
    
    while let Some(op) = match parser.current.type {
        TokenType::PLUS => { advance(parser); Some(BinaryOp::Add) }
        TokenType::MINUS => { advance(parser); Some(BinaryOp::Sub) }
        _ => None
    } {
        let right = parse_multiplicative(parser)?;
        expr = Expression::Binary(op, Box::new(expr), Box::new(right));
    }
    
    Ok(expr)
}

function parse_multiplicative(parser: &mut Parser) -> Result<Expression, ()> {
    let mut expr = parse_unary(parser)?;
    
    while let Some(op) = match parser.current.type {
        TokenType::STAR => { advance(parser); Some(BinaryOp::Mul) }
        TokenType::SLASH => { advance(parser); Some(BinaryOp::Div) }
        TokenType::PERCENT => { advance(parser); Some(BinaryOp::Rem) }
        _ => None
    } {
        let right = parse_unary(parser)?;
        expr = Expression::Binary(op, Box::new(expr), Box::new(right));
    }
    
    Ok(expr)
}

function parse_unary(parser: &mut Parser) -> Result<Expression, ()> {
    if let Some(op) = match parser.current.type {
        TokenType::EXCLAMATION => { advance(parser); Some(UnaryOp::Not) }
        TokenType::MINUS => { advance(parser); Some(UnaryOp::Neg) }
        TokenType::TILDE => { advance(parser); Some(UnaryOp::BitNot) }
        _ => None
    } {
        let expr = parse_unary(parser)?;
        return Ok(Expression::Unary(op, Box::new(expr)));
    }
    
    if match_token(parser, TokenType::AMPERSAND) {
        let mutability = if match_token(parser, TokenType::MUT) {
            Mutability::Mutable
        } else {
            Mutability::Immutable
        };
        let expr = parse_unary(parser)?;
        return Ok(Expression::Ref(Box::new(expr), mutability));
    }
    
    if match_token(parser, TokenType::STAR) {
        let expr = parse_unary(parser)?;
        return Ok(Expression::Deref(Box::new(expr)));
    }
    
    parse_postfix(parser)
}

function parse_postfix(parser: &mut Parser) -> Result<Expression, ()> {
    let mut expr = parse_primary(parser)?;
    
    loop {
        if match_token(parser, TokenType::LPAREN) {
            // Function call
            let args = parse_arguments(parser)?;
            consume(parser, TokenType::RPAREN, "Expected ')'")?;
            expr = Expression::Call(Box::new(expr), args);
        } else if match_token(parser, TokenType::DOT) {
            // Field access or method call
            let field = consume_identifier(parser, "Expected field name")?;
            if match_token(parser, TokenType::LPAREN) {
                let args = parse_arguments(parser)?;
                consume(parser, TokenType::RPAREN, "Expected ')'")?;
                expr = Expression::MethodCall(Box::new(expr), field, args);
            } else {
                expr = Expression::Field(Box::new(expr), field);
            }
        } else if match_token(parser, TokenType::LBRACKET) {
            // Array index
            let index = parse_expression(parser)?;
            consume(parser, TokenType::RBRACKET, "Expected ']'")?;
            expr = Expression::Index(Box::new(expr), Box::new(index));
        } else if match_token(parser, TokenType::QUESTION) {
            // Error propagation (TODO)
            expr = Expression::Error;
        } else {
            break;
        }
    }
    
    Ok(expr)
}

function parse_primary(parser: &mut Parser) -> Result<Expression, ()> {
    // Literals
    if let Some(lit) = parse_literal(parser)? {
        return Ok(Expression::Literal(lit));
    }
    
    // Identifiers and paths
    if check(parser, TokenType::IDENTIFIER) || check(parser, TokenType::DOUBLE_COLON) {
        let path = parse_path(parser)?;
        
        // Check for struct construction
        if match_token(parser, TokenType::LBRACE) {
            let fields = parse_field_inits(parser)?;
            consume(parser, TokenType::RBRACE, "Expected '}'")?;
            return Ok(Expression::Struct(path, fields));
        }
        
        // Check if it's a simple variable
        if path.segments.len() == 1 && path.segments[0].args.is_none() {
            return Ok(Expression::Variable(path.segments[0].name.clone()));
        }
        
        return Ok(Expression::Path(path));
    }
    
    // Parenthesized expression or tuple
    if match_token(parser, TokenType::LPAREN) {
        if check(parser, TokenType::RPAREN) {
            advance(parser);
            return Ok(Expression::Literal(Literal::Unit));
        }
        
        let mut exprs = vec![parse_expression(parser)?];
        
        while match_token(parser, TokenType::COMMA) {
            if check(parser, TokenType::RPAREN) {
                break;
            }
            exprs.push(parse_expression(parser)?);
        }
        
        consume(parser, TokenType::RPAREN, "Expected ')'")?;
        
        if exprs.len() == 1 && !parser.previous.value.contains(',') {
            return Ok(exprs.into_iter().next().unwrap());
        }
        
        return Ok(Expression::Tuple(exprs));
    }
    
    // Array literal
    if match_token(parser, TokenType::LBRACKET) {
        let mut elements = Vec::new();
        
        if !check(parser, TokenType::RBRACKET) {
            loop {
                elements.push(parse_expression(parser)?);
                if !match_token(parser, TokenType::COMMA) {
                    break;
                }
            }
        }
        
        consume(parser, TokenType::RBRACKET, "Expected ']'")?;
        return Ok(Expression::Array(elements));
    }
    
    // Block expression
    if check(parser, TokenType::LBRACE) {
        return Ok(Expression::Block(parse_block(parser)?));
    }
    
    // Control flow
    if match_token(parser, TokenType::IF) {
        return parse_if_expression(parser);
    }
    
    if match_token(parser, TokenType::WHILE) {
        return parse_while_expression(parser);
    }
    
    if match_token(parser, TokenType::FOR) {
        return parse_for_expression(parser);
    }
    
    if match_token(parser, TokenType::LOOP) {
        return parse_loop_expression(parser);
    }
    
    if match_token(parser, TokenType::MATCH) {
        return parse_match_expression(parser);
    }
    
    // Async/await
    if match_token(parser, TokenType::ASYNC) {
        let expr = parse_expression(parser)?;
        return Ok(Expression::Async(Box::new(expr)));
    }
    
    if match_token(parser, TokenType::AWAIT) {
        let expr = parse_postfix(parser)?;
        return Ok(Expression::Await(Box::new(expr)));
    }
    
    // Defer
    if match_token(parser, TokenType::DEFER) {
        let expr = parse_expression(parser)?;
        return Ok(Expression::Defer(Box::new(expr)));
    }
    
    // WCET annotation
    if match_token(parser, TokenType::WITHIN) {
        return parse_within_expression(parser);
    }
    
    // Memory annotation
    if match_token(parser, TokenType::MEMORY) {
        return parse_memory_expression(parser);
    }
    
    error(parser, "Expected expression");
    Ok(Expression::Error)
}

// ===========================================================================
// Pattern parsing
// ===========================================================================

function parse_pattern(parser: &mut Parser) -> Result<Pattern, ()> {
    push_context(parser, ParseContext::Pattern);
    let result = parse_pattern_or(parser);
    pop_context(parser);
    result
}

function parse_pattern_or(parser: &mut Parser) -> Result<Pattern, ()> {
    let mut patterns = vec![parse_pattern_primary(parser)?];
    
    while match_token(parser, TokenType::PIPE) {
        patterns.push(parse_pattern_primary(parser)?);
    }
    
    if patterns.len() == 1 {
        Ok(patterns.into_iter().next().unwrap())
    } else {
        Ok(Pattern::Or(patterns))
    }
}

function parse_pattern_primary(parser: &mut Parser) -> Result<Pattern, ()> {
    // Wildcard
    if match_token(parser, TokenType::IDENTIFIER) && parser.previous.value == "_" {
        return Ok(Pattern::Wildcard);
    }
    
    // Literal patterns
    if let Some(lit) = parse_literal(parser)? {
        return Ok(Pattern::Literal(lit));
    }
    
    // Reference patterns
    if match_token(parser, TokenType::AMPERSAND) {
        let mutability = if match_token(parser, TokenType::MUT) {
            Mutability::Mutable
        } else {
            Mutability::Immutable
        };
        let pattern = parse_pattern_primary(parser)?;
        return Ok(Pattern::Reference(Box::new(pattern), mutability));
    }
    
    // Tuple patterns
    if match_token(parser, TokenType::LPAREN) {
        let mut patterns = Vec::new();
        
        if !check(parser, TokenType::RPAREN) {
            loop {
                patterns.push(parse_pattern(parser)?);
                if !match_token(parser, TokenType::COMMA) {
                    break;
                }
            }
        }
        
        consume(parser, TokenType::RPAREN, "Expected ')'")?;
        return Ok(Pattern::Tuple(patterns));
    }
    
    // Array/slice patterns
    if match_token(parser, TokenType::LBRACKET) {
        let mut patterns = Vec::new();
        
        while !check(parser, TokenType::RBRACKET) {
            patterns.push(parse_pattern(parser)?);
            if !match_token(parser, TokenType::COMMA) {
                break;
            }
        }
        
        consume(parser, TokenType::RBRACKET, "Expected ']'")?;
        return Ok(Pattern::Array(patterns));
    }
    
    // Path patterns (enum variants, structs)
    if check(parser, TokenType::IDENTIFIER) || check(parser, TokenType::DOUBLE_COLON) {
        let path = parse_path(parser)?;
        
        // Struct pattern
        if match_token(parser, TokenType::LBRACE) {
            let mut fields = Vec::new();
            
            while !check(parser, TokenType::RBRACE) {
                let name = consume_identifier(parser, "Expected field name")?;
                let pattern = if match_token(parser, TokenType::COLON) {
                    parse_pattern(parser)?
                } else {
                    Pattern::Variable(name.clone(), None)
                };
                
                fields.push(FieldPattern {
                    name,
                    pattern,
                    span: parser.previous.span,
                });
                
                if !match_token(parser, TokenType::COMMA) {
                    break;
                }
            }
            
            consume(parser, TokenType::RBRACE, "Expected '}'")?;
            return Ok(Pattern::Struct(path, fields));
        }
        
        // Tuple enum pattern
        if match_token(parser, TokenType::LPAREN) {
            let mut patterns = Vec::new();
            
            if !check(parser, TokenType::RPAREN) {
                loop {
                    patterns.push(parse_pattern(parser)?);
                    if !match_token(parser, TokenType::COMMA) {
                        break;
                    }
                }
            }
            
            consume(parser, TokenType::RPAREN, "Expected ')'")?;
            return Ok(Pattern::Enum(path, patterns));
        }
        
        // Simple identifier pattern
        if path.segments.len() == 1 && !path.is_absolute {
            let mutability = if match_token(parser, TokenType::MUT) {
                Some(Mutability::Mutable)
            } else {
                None
            };
            return Ok(Pattern::Variable(path.segments[0].name.clone(), mutability));
        }
        
        // Unit enum variant
        return Ok(Pattern::Enum(path, Vec::new()));
    }
    
    error(parser, "Expected pattern");
    Ok(Pattern::Wildcard)
}

// ===========================================================================
// Type expression parsing
// ===========================================================================

function parse_type_expr(parser: &mut Parser) -> Result<TypeExpr, ()> {
    // References
    if match_token(parser, TokenType::AMPERSAND) {
        let lifetime = if match_token(parser, TokenType::LIFETIME) {
            Some(Lifetime {
                name: parser.previous.value.clone(),
                span: parser.previous.span,
            })
        } else {
            None
        };
        
        let mutability = if match_token(parser, TokenType::MUT) {
            Mutability::Mutable
        } else {
            Mutability::Immutable
        };
        
        let inner = parse_type_expr(parser)?;
        return Ok(TypeExpr::Reference(Box::new(inner), mutability, lifetime));
    }
    
    // Pointers
    if match_token(parser, TokenType::STAR) {
        let mutability = if match_token(parser, TokenType::MUT) {
            Mutability::Mutable
        } else if match_token(parser, TokenType::CONST) {
            Mutability::Immutable
        } else {
            error(parser, "Expected 'mut' or 'const' after '*'");
            Mutability::Immutable
        };
        
        let inner = parse_type_expr(parser)?;
        return Ok(TypeExpr::Pointer(Box::new(inner), mutability));
    }
    
    // Arrays
    if match_token(parser, TokenType::LBRACKET) {
        let elem = parse_type_expr(parser)?;
        let size = if match_token(parser, TokenType::SEMICOLON) {
            Some(parse_expression(parser)?)
        } else {
            None
        };
        consume(parser, TokenType::RBRACKET, "Expected ']'")?;
        return Ok(TypeExpr::Array(Box::new(elem), size));
    }
    
    // Tuples
    if match_token(parser, TokenType::LPAREN) {
        if check(parser, TokenType::RPAREN) {
            advance(parser);
            return Ok(TypeExpr::Tuple(Vec::new()));
        }
        
        let mut types = vec![parse_type_expr(parser)?];
        
        while match_token(parser, TokenType::COMMA) {
            if check(parser, TokenType::RPAREN) {
                break;
            }
            types.push(parse_type_expr(parser)?);
        }
        
        consume(parser, TokenType::RPAREN, "Expected ')'")?;
        
        if types.len() == 1 && !parser.previous.value.contains(',') {
            return Ok(types.into_iter().next().unwrap());
        }
        
        return Ok(TypeExpr::Tuple(types));
    }
    
    // Function types
    if match_token(parser, TokenType::FUNCTION) {
        return parse_function_type(parser);
    }
    
    // Linear types
    if match_token(parser, TokenType::IDENTIFIER) && parser.previous.value == "linear" {
        let inner = parse_type_expr(parser)?;
        return Ok(TypeExpr::Linear(Box::new(inner)));
    }
    
    // Never type
    if match_token(parser, TokenType::EXCLAMATION) {
        return Ok(TypeExpr::Never);
    }
    
    // Infer type
    if match_token(parser, TokenType::IDENTIFIER) && parser.previous.value == "_" {
        return Ok(TypeExpr::Infer);
    }
    
    // Primitive types
    if let Some(prim) = parse_primitive_type(parser)? {
        return Ok(TypeExpr::Primitive(prim));
    }
    
    // Paths (user-defined types)
    if check(parser, TokenType::IDENTIFIER) || check(parser, TokenType::DOUBLE_COLON) {
        let path = parse_path(parser)?;
        return Ok(TypeExpr::Path(path));
    }
    
    error(parser, "Expected type");
    Ok(TypeExpr::Never)
}

// ===========================================================================
// Statement parsing
// ===========================================================================

function parse_statement(parser: &mut Parser) -> Result<Statement, ()> {
    push_context(parser, ParseContext::Statement);
    
    let result = if match_token(parser, TokenType::LET) {
        parse_let_statement(parser)
    } else if match_token(parser, TokenType::RETURN) {
        let expr = if check(parser, TokenType::SEMICOLON) {
            None
        } else {
            Some(parse_expression(parser)?)
        };
        consume(parser, TokenType::SEMICOLON, "Expected ';'")?;
        Ok(Statement::Return(expr))
    } else if match_token(parser, TokenType::BREAK) {
        let label = if check(parser, TokenType::IDENTIFIER) {
            Some(consume_identifier(parser, "Expected label")?)
        } else {
            None
        };
        consume(parser, TokenType::SEMICOLON, "Expected ';'")?;
        Ok(Statement::Break(label))
    } else if match_token(parser, TokenType::CONTINUE) {
        let label = if check(parser, TokenType::IDENTIFIER) {
            Some(consume_identifier(parser, "Expected label")?)
        } else {
            None
        };
        consume(parser, TokenType::SEMICOLON, "Expected ';'")?;
        Ok(Statement::Continue(label))
    } else if is_item_start(parser) {
        Ok(Statement::Item(parse_item(parser)?))
    } else {
        let expr = parse_expression(parser)?;
        if !check(parser, TokenType::RBRACE) && !is_at_end(parser) {
            consume(parser, TokenType::SEMICOLON, "Expected ';'")?;
        }
        Ok(Statement::Expression(expr))
    };
    
    pop_context(parser);
    result
}

function parse_let_statement(parser: &mut Parser) -> Result<Statement, ()> {
    let pattern = parse_pattern(parser)?;
    
    let type_annotation = if match_token(parser, TokenType::COLON) {
        Some(parse_type_expr(parser)?)
    } else {
        None
    };
    
    let initializer = if match_token(parser, TokenType::EQUALS) {
        Some(parse_expression(parser)?)
    } else {
        None
    };
    
    consume(parser, TokenType::SEMICOLON, "Expected ';'")?;
    
    Ok(Statement::Let(pattern, type_annotation, initializer))
}

// ===========================================================================
// Block parsing
// ===========================================================================

function parse_block(parser: &mut Parser) -> Result<Block, ()> {
    let start_span = consume(parser, TokenType::LBRACE, "Expected '{'")?;
    push_context(parser, ParseContext::Block);
    
    let mut statements = Vec::new();
    let mut final_expr = None;
    
    while !check(parser, TokenType::RBRACE) && !is_at_end(parser) {
        // Check if this might be the final expression
        if is_expression_start(parser) && peek_is_block_end(parser) {
            final_expr = Some(Box::new(parse_expression(parser)?));
            break;
        }
        
        statements.push(parse_statement(parser)?);
    }
    
    consume(parser, TokenType::RBRACE, "Expected '}'")?;
    pop_context(parser);
    
    Ok(Block {
        statements,
        final_expr,
        span: span_union(start_span, parser.previous.span),
    })
}

// ===========================================================================
// Helper parsing functions
// ===========================================================================

function parse_arguments(parser: &mut Parser) -> Result<Vec<Expression>, ()> {
    let mut args = Vec::new();
    
    if !check(parser, TokenType::RPAREN) {
        loop {
            args.push(parse_expression(parser)?);
            if !match_token(parser, TokenType::COMMA) {
                break;
            }
        }
    }
    
    Ok(args)
}

function parse_field_inits(parser: &mut Parser) -> Result<Vec<FieldInit>, ()> {
    let mut fields = Vec::new();
    
    while !check(parser, TokenType::RBRACE) {
        let start_span = parser.current.span;
        let name = consume_identifier(parser, "Expected field name")?;
        
        let value = if match_token(parser, TokenType::COLON) {
            parse_expression(parser)?
        } else {
            // Field shorthand
            Expression::Variable(name.clone())
        };
        
        fields.push(FieldInit {
            name,
            value,
            span: span_union(start_span, parser.previous.span),
        });
        
        if !match_token(parser, TokenType::COMMA) {
            break;
        }
    }
    
    Ok(fields)
}

function parse_literal(parser: &mut Parser) -> Result<Option<Literal>, ()> {
    match parser.current.type {
        TokenType::NUMBER => {
            let value = parser.current.value.clone();
            advance(parser);
            
            // Parse number literal with optional type suffix
            if value.contains('.') || value.contains('e') || value.contains('E') {
                // Float literal
                let (num_str, type_suffix) = split_number_suffix(&value);
                let num = num_str.parse::<f64>().unwrap_or(0.0);
                let float_type = match type_suffix.as_str() {
                    "f32" => Some(FloatType::F32),
                    "f64" => Some(FloatType::F64),
                    _ => None,
                };
                Ok(Some(Literal::Float(num, float_type)))
            } else {
                // Integer literal
                let (num_str, type_suffix) = split_number_suffix(&value);
                let num = parse_integer(&num_str).unwrap_or(0);
                let int_type = match type_suffix.as_str() {
                    "i8" => Some(IntegerType::I8),
                    "i16" => Some(IntegerType::I16),
                    "i32" => Some(IntegerType::I32),
                    "i64" => Some(IntegerType::I64),
                    "i128" => Some(IntegerType::I128),
                    "u8" => Some(IntegerType::U8),
                    "u16" => Some(IntegerType::U16),
                    "u32" => Some(IntegerType::U32),
                    "u64" => Some(IntegerType::U64),
                    "u128" => Some(IntegerType::U128),
                    _ => None,
                };
                Ok(Some(Literal::Integer(num, int_type)))
            }
        }
        TokenType::STRING => {
            let value = parser.current.value.clone();
            advance(parser);
            Ok(Some(Literal::String(value)))
        }
        TokenType::CHAR => {
            let value = parser.current.value.chars().next().unwrap_or('\0');
            advance(parser);
            Ok(Some(Literal::Char(value)))
        }
        TokenType::TRUE => {
            advance(parser);
            Ok(Some(Literal::Bool(true)))
        }
        TokenType::FALSE => {
            advance(parser);
            Ok(Some(Literal::Bool(false)))
        }
        _ => Ok(None)
    }
}

function parse_path(parser: &mut Parser) -> Result<Path, ()> {
    let start_span = parser.current.span;
    let mut segments = Vec::new();
    let is_absolute = match_token(parser, TokenType::DOUBLE_COLON);
    
    loop {
        let name = consume_identifier(parser, "Expected identifier in path")?;
        let args = if match_token(parser, TokenType::LESS_THAN) {
            Some(parse_generic_args(parser)?)
        } else {
            None
        };
        
        segments.push(PathSegment {
            name,
            args,
            span: parser.previous.span,
        });
        
        if !match_token(parser, TokenType::DOUBLE_COLON) {
            break;
        }
    }
    
    Ok(Path {
        segments,
        is_absolute,
        span: span_union(start_span, parser.previous.span),
    })
}

function parse_visibility(parser: &mut Parser) -> Result<Visibility, ()> {
    if match_token(parser, TokenType::PUBLIC) {
        Ok(Visibility::Public)
    } else if match_token(parser, TokenType::PRIVATE) {
        Ok(Visibility::Private)
    } else {
        Ok(Visibility::Private)
    }
}

function parse_attributes(parser: &mut Parser) -> Result<Vec<Attribute>, ()> {
    let mut attributes = Vec::new();
    
    while match_token(parser, TokenType::HASH) {
        consume(parser, TokenType::LBRACKET, "Expected '[' after '#'")?;
        let start_span = parser.current.span;
        let name = consume_identifier(parser, "Expected attribute name")?;
        
        let mut args = Vec::new();
        if match_token(parser, TokenType::LPAREN) {
            while !check(parser, TokenType::RPAREN) {
                // Parse attribute arguments
                if let Some(lit) = parse_literal(parser)? {
                    args.push(AttributeArg::Literal(lit));
                }
                if !match_token(parser, TokenType::COMMA) {
                    break;
                }
            }
            consume(parser, TokenType::RPAREN, "Expected ')'")?;
        }
        
        consume(parser, TokenType::RBRACKET, "Expected ']'")?;
        
        attributes.push(Attribute {
            name,
            args,
            span: span_union(start_span, parser.previous.span),
        });
    }
    
    Ok(attributes)
}

// ===========================================================================
// Error recovery
// ===========================================================================

function synchronize(parser: &mut Parser) {
    parser.panic_mode = false;
    
    while !is_at_end(parser) {
        if parser.previous.type == TokenType::SEMICOLON {
            return;
        }
        
        if parser.synchronize_points.contains(&parser.current.type) {
            return;
        }
        
        advance(parser);
    }
}

function synchronize_until(parser: &mut Parser, tokens: &[TokenType]) {
    while !is_at_end(parser) {
        if tokens.contains(&parser.current.type) {
            return;
        }
        advance(parser);
    }
}

function error(parser: &mut Parser, message: &str) {
    if parser.panic_mode {
        return;
    }
    
    parser.panic_mode = true;
    
    let mut context = Vec::new();
    for ctx in &parser.context_stack {
        context.push(format!("In {}", ctx));
    }
    
    parser.errors.push(ParseError {
        message: message.to_string(),
        span: parser.current.span,
        context,
        suggestions: suggest_fixes(parser, message),
    });
}

function suggest_fixes(parser: &Parser, message: &str) -> Vec<String> {
    let mut suggestions = Vec::new();
    
    if message.contains("Expected ';'") {
        suggestions.push("Add a semicolon at the end of the statement".to_string());
    }
    
    if message.contains("Expected identifier") && parser.current.type == TokenType::NUMBER {
        suggestions.push("Identifiers cannot start with numbers".to_string());
    }
    
    // Add more contextual suggestions based on error patterns
    
    suggestions
}

// ===========================================================================
// Utility functions
// ===========================================================================

function advance(parser: &mut Parser) -> Token {
    if !is_at_end(parser) {
        parser.previous = parser.current.clone();
        parser.current = next_token(&mut parser.lexer);
    }
    parser.previous.clone()
}

function check(parser: &Parser, type: TokenType) -> bool {
    parser.current.type == type
}

function match_token(parser: &mut Parser, type: TokenType) -> bool {
    if check(parser, type) {
        advance(parser);
        true
    } else {
        false
    }
}

function consume(parser: &mut Parser, type: TokenType, message: &str) -> Result<Span, ()> {
    if check(parser, type) {
        Ok(advance(parser).span)
    } else {
        error(parser, message);
        Err(())
    }
}

function consume_identifier(parser: &mut Parser, message: &str) -> Result<String, ()> {
    if check(parser, TokenType::IDENTIFIER) {
        Ok(advance(parser).value)
    } else {
        error(parser, message);
        Err(())
    }
}

function consume_string(parser: &mut Parser, message: &str) -> Result<String, ()> {
    if check(parser, TokenType::STRING) {
        Ok(advance(parser).value)
    } else {
        error(parser, message);
        Err(())
    }
}

function is_at_end(parser: &Parser) -> bool {
    parser.current.type == TokenType::EOF
}

function push_context(parser: &mut Parser, context: ParseContext) {
    parser.context_stack.push(context);
}

function pop_context(parser: &mut Parser) {
    parser.context_stack.pop();
}

function is_item_start(parser: &Parser) -> bool {
    matches!(
        parser.current.type,
        TokenType::FUNCTION | TokenType::TYPE | TokenType::ENUM | 
        TokenType::TRAIT | TokenType::IMPL | TokenType::CONST | 
        TokenType::STATIC | TokenType::PUBLIC | TokenType::PRIVATE
    )
}

function is_expression_start(parser: &Parser) -> bool {
    matches!(
        parser.current.type,
        TokenType::NUMBER | TokenType::STRING | TokenType::CHAR |
        TokenType::TRUE | TokenType::FALSE | TokenType::IDENTIFIER |
        TokenType::LPAREN | TokenType::LBRACKET | TokenType::LBRACE |
        TokenType::IF | TokenType::WHILE | TokenType::FOR | TokenType::LOOP |
        TokenType::MATCH | TokenType::EXCLAMATION | TokenType::MINUS |
        TokenType::TILDE | TokenType::AMPERSAND | TokenType::STAR |
        TokenType::ASYNC | TokenType::AWAIT | TokenType::DEFER |
        TokenType::WITHIN | TokenType::MEMORY | TokenType::DOUBLE_COLON
    )
}

function peek_is_block_end(parser: &mut Parser) -> bool {
    // Save current state
    let saved_pos = parser.lexer.position;
    let saved_current = parser.current.clone();
    
    // Skip the current expression
    while !check(parser, TokenType::SEMICOLON) && 
          !check(parser, TokenType::RBRACE) && 
          !is_at_end(parser) {
        advance(parser);
    }
    
    let is_end = check(parser, TokenType::RBRACE);
    
    // Restore state
    parser.lexer.position = saved_pos;
    parser.current = saved_current;
    
    is_end
}

// ===========================================================================
// Incremental parsing support
// ===========================================================================

function create_checkpoint(parser: &mut Parser) {
    parser.checkpoint_stack.push(ParserCheckpoint {
        position: parser.lexer.position,
        token: parser.current.clone(),
        errors_count: parser.errors.len(),
    });
}

function restore_checkpoint(parser: &mut Parser) {
    if let Some(checkpoint) = parser.checkpoint_stack.pop() {
        parser.lexer.position = checkpoint.position;
        parser.current = checkpoint.token;
        parser.errors.truncate(checkpoint.errors_count);
        parser.panic_mode = false;
    }
}

function commit_checkpoint(parser: &mut Parser) {
    parser.checkpoint_stack.pop();
}

function parse_incremental(
    parser: &mut Parser, 
    old_ast: &Program, 
    changed_range: Range
) -> Result<Program, Vec<ParseError>> {
    parser.modified_ranges.push(changed_range);
    
    // Find affected AST nodes and reparse only those
    // This is a simplified version - real implementation would be more sophisticated
    
    parse_program(parser)
}

// ===========================================================================
// Additional parsing functions that were referenced but not implemented
// ===========================================================================

function parse_if_expression(parser: &mut Parser) -> Result<Expression, ()> {
    let condition = parse_expression(parser)?;
    let then_branch = parse_block(parser)?;
    let else_branch = if match_token(parser, TokenType::ELSE) {
        if check(parser, TokenType::IF) {
            Some(Box::new(parse_expression(parser)?))
        } else {
            Some(Box::new(Expression::Block(parse_block(parser)?)))
        }
    } else {
        None
    };
    
    Ok(Expression::If(
        Box::new(condition),
        Box::new(Expression::Block(then_branch)),
        else_branch
    ))
}

function parse_while_expression(parser: &mut Parser) -> Result<Expression, ()> {
    let condition = parse_expression(parser)?;
    let body = parse_block(parser)?;
    
    Ok(Expression::While(
        Box::new(condition),
        Box::new(Expression::Block(body))
    ))
}

function parse_for_expression(parser: &mut Parser) -> Result<Expression, ()> {
    let pattern = parse_pattern(parser)?;
    consume(parser, TokenType::IDENTIFIER, "Expected 'in'")?; // Should check for "in"
    let iterator = parse_expression(parser)?;
    let body = parse_block(parser)?;
    
    Ok(Expression::For(
        pattern,
        Box::new(iterator),
        Box::new(Expression::Block(body))
    ))
}

function parse_loop_expression(parser: &mut Parser) -> Result<Expression, ()> {
    let body = parse_block(parser)?;
    Ok(Expression::Loop(Box::new(Expression::Block(body))))
}

function parse_match_expression(parser: &mut Parser) -> Result<Expression, ()> {
    let scrutinee = parse_expression(parser)?;
    consume(parser, TokenType::LBRACE, "Expected '{'")?;
    
    let mut arms = Vec::new();
    while !check(parser, TokenType::RBRACE) {
        arms.push(parse_match_arm(parser)?);
        if !match_token(parser, TokenType::COMMA) && !check(parser, TokenType::RBRACE) {
            error(parser, "Expected ',' or '}'");
        }
    }
    
    consume(parser, TokenType::RBRACE, "Expected '}'")?;
    
    Ok(Expression::Match(Box::new(scrutinee), arms))
}

function parse_match_arm(parser: &mut Parser) -> Result<MatchArm, ()> {
    let start_span = parser.current.span;
    let pattern = parse_pattern(parser)?;
    
    let guard = if match_token(parser, TokenType::IF) {
        Some(parse_expression(parser)?)
    } else {
        None
    };
    
    consume(parser, TokenType::FAT_ARROW, "Expected '=>'")?;
    let body = parse_expression(parser)?;
    
    Ok(MatchArm {
        pattern,
        guard,
        body,
        span: span_union(start_span, parser.previous.span),
    })
}

function parse_within_expression(parser: &mut Parser) -> Result<Expression, ()> {
    let bound = parse_wcet_bound(parser)?;
    let expr = parse_block(parser)?;
    
    Ok(Expression::Within(
        Box::new(Expression::Block(expr)),
        bound
    ))
}

function parse_memory_expression(parser: &mut Parser) -> Result<Expression, ()> {
    let size = parse_integer(&parser.current.value).unwrap_or(0) as u64;
    advance(parser);
    
    let unit = if match_token(parser, TokenType::BYTES) {
        MemoryUnit::Bytes
    } else if match_token(parser, TokenType::KILOBYTES) {
        MemoryUnit::Kilobytes
    } else if match_token(parser, TokenType::MEGABYTES) {
        MemoryUnit::Megabytes
    } else if match_token(parser, TokenType::GIGABYTES) {
        MemoryUnit::Gigabytes
    } else {
        error(parser, "Expected memory unit");
        MemoryUnit::Bytes
    };
    
    let expr = parse_block(parser)?;
    
    Ok(Expression::Memory(
        Box::new(Expression::Block(expr)),
        MemoryBound {
            size,
            unit,
            span: parser.previous.span,
        }
    ))
}

function parse_wcet_annotation(parser: &mut Parser) -> Result<WCETAnnotation, ()> {
    let start_span = parser.current.span;
    let bound = parse_wcet_bound(parser)?;
    
    let condition = if match_token(parser, TokenType::IF) {
        Some(parse_expression(parser)?)
    } else {
        None
    };
    
    Ok(WCETAnnotation {
        bound,
        condition,
        span: span_union(start_span, parser.previous.span),
    })
}

function parse_wcet_bound(parser: &mut Parser) -> Result<WCETBound, ()> {
    if check(parser, TokenType::NUMBER) {
        let value = parse_integer(&parser.current.value).unwrap_or(0) as u64;
        advance(parser);
        
        let unit = if match_token(parser, TokenType::CYCLES) {
            TimeUnit::Cycles
        } else if match_token(parser, TokenType::NANOSECONDS) {
            TimeUnit::Nanoseconds
        } else if match_token(parser, TokenType::MICROSECONDS) {
            TimeUnit::Microseconds
        } else if match_token(parser, TokenType::MILLISECONDS) {
            TimeUnit::Milliseconds
        } else if match_token(parser, TokenType::SECONDS) {
            TimeUnit::Seconds
        } else {
            TimeUnit::Cycles
        };
        
        Ok(WCETBound::Constant(value, unit))
    } else if match_token(parser, TokenType::IDENTIFIER) {
        let name = parser.previous.value.clone();
        
        if match_token(parser, TokenType::LPAREN) {
            let var = consume_identifier(parser, "Expected variable")?;
            consume(parser, TokenType::RPAREN, "Expected ')'")?;
            
            match name.as_str() {
                "O" => Ok(WCETBound::Linear(var)),
                "log" => Ok(WCETBound::Logarithmic(var)),
                _ => {
                    error(parser, "Unknown complexity function");
                    Ok(WCETBound::Linear(var))
                }
            }
        } else {
            Ok(WCETBound::Expression(Expression::Variable(name)))
        }
    } else {
        error(parser, "Expected WCET bound");
        Ok(WCETBound::Constant(0, TimeUnit::Cycles))
    }
}

function parse_generic_params(parser: &mut Parser) -> Result<GenericParams, ()> {
    let start_span = consume(parser, TokenType::LESS_THAN, "Expected '<'")?;
    let mut params = Vec::new();
    
    while !check(parser, TokenType::GREATER_THAN) {
        params.push(parse_generic_param(parser)?);
        if !match_token(parser, TokenType::COMMA) {
            break;
        }
    }
    
    consume(parser, TokenType::GREATER_THAN, "Expected '>'")?;
    
    let where_clause = if match_token(parser, TokenType::IDENTIFIER) && parser.previous.value == "where" {
        Some(parse_where_clause(parser)?)
    } else {
        None
    };
    
    Ok(GenericParams {
        params,
        where_clause,
        span: span_union(start_span, parser.previous.span),
    })
}

function parse_generic_param(parser: &mut Parser) -> Result<GenericParam, ()> {
    let start_span = parser.current.span;
    
    // Lifetime parameter
    if match_token(parser, TokenType::LIFETIME) {
        let name = parser.previous.value.clone();
        let bounds = if match_token(parser, TokenType::COLON) {
            parse_lifetime_bounds(parser)?
        } else {
            Vec::new()
        };
        
        return Ok(GenericParam {
            name,
            bounds: Vec::new(),
            default: None,
            kind: GenericParamKind::Lifetime,
            span: span_union(start_span, parser.previous.span),
        });
    }
    
    // Const parameter
    if match_token(parser, TokenType::CONST) {
        let name = consume_identifier(parser, "Expected const parameter name")?;
        consume(parser, TokenType::COLON, "Expected ':'")?;
        let ty = parse_type_expr(parser)?;
        
        return Ok(GenericParam {
            name,
            bounds: Vec::new(),
            default: None,
            kind: GenericParamKind::Const(ty),
            span: span_union(start_span, parser.previous.span),
        });
    }
    
    // Type parameter
    let name = consume_identifier(parser, "Expected generic parameter name")?;
    let bounds = if match_token(parser, TokenType::COLON) {
        parse_trait_bounds(parser)?
    } else {
        Vec::new()
    };
    
    let default = if match_token(parser, TokenType::EQUALS) {
        Some(parse_type_expr(parser)?)
    } else {
        None
    };
    
    Ok(GenericParam {
        name,
        bounds,
        default,
        kind: GenericParamKind::Type,
        span: span_union(start_span, parser.previous.span),
    })
}

function parse_trait_bounds(parser: &mut Parser) -> Result<Vec<TraitBound>, ()> {
    let mut bounds = Vec::new();
    
    loop {
        let modifier = if match_token(parser, TokenType::QUESTION) {
            Some(TraitBoundModifier::Maybe)
        } else {
            None
        };
        
        let path = parse_path(parser)?;
        let args = if match_token(parser, TokenType::LESS_THAN) {
            parse_generic_args(parser)?
        } else {
            GenericArgs {
                args: Vec::new(),
                span: parser.previous.span,
            }
        };
        
        bounds.push(TraitBound {
            path,
            args: args.args,
            modifier,
        });
        
        if !match_token(parser, TokenType::PLUS) {
            break;
        }
    }
    
    Ok(bounds)
}

function parse_generic_args(parser: &mut Parser) -> Result<GenericArgs, ()> {
    let start_span = parser.current.span;
    let mut args = Vec::new();
    
    while !check(parser, TokenType::GREATER_THAN) {
        // Lifetime arguments
        if match_token(parser, TokenType::LIFETIME) {
            args.push(GenericArg::Lifetime(Lifetime {
                name: parser.previous.value.clone(),
                span: parser.previous.span,
            }));
        } else if check(parser, TokenType::CONST) {
            // Const arguments
            advance(parser);
            let expr = parse_expression(parser)?;
            args.push(GenericArg::Const(expr));
        } else {
            // Type arguments
            let ty = parse_type_expr(parser)?;
            args.push(GenericArg::Type(ty));
        }
        
        if !match_token(parser, TokenType::COMMA) {
            break;
        }
    }
    
    consume(parser, TokenType::GREATER_THAN, "Expected '>'")?;
    
    Ok(GenericArgs {
        args,
        span: span_union(start_span, parser.previous.span),
    })
}

function parse_where_clause(parser: &mut Parser) -> Result<WhereClause, ()> {
    let start_span = parser.previous.span;
    let mut predicates = Vec::new();
    
    loop {
        if match_token(parser, TokenType::LIFETIME) {
            // Lifetime bounds
            let lifetime = Lifetime {
                name: parser.previous.value.clone(),
                span: parser.previous.span,
            };
            consume(parser, TokenType::COLON, "Expected ':'")?;
            let bounds = parse_lifetime_bounds(parser)?;
            predicates.push(WherePredicate::LifetimeBound(lifetime, bounds));
        } else {
            // Type bounds
            let ty = parse_type_expr(parser)?;
            consume(parser, TokenType::COLON, "Expected ':'")?;
            let bounds = parse_trait_bounds(parser)?;
            predicates.push(WherePredicate::TypeBound(ty, bounds));
        }
        
        if !match_token(parser, TokenType::COMMA) {
            break;
        }
    }
    
    Ok(WhereClause {
        predicates,
        span: span_union(start_span, parser.previous.span),
    })
}

function parse_lifetime_bounds(parser: &mut Parser) -> Result<Vec<Lifetime>, ()> {
    let mut bounds = Vec::new();
    
    loop {
        if match_token(parser, TokenType::LIFETIME) {
            bounds.push(Lifetime {
                name: parser.previous.value.clone(),
                span: parser.previous.span,
            });
        } else {
            break;
        }
        
        if !match_token(parser, TokenType::PLUS) {
            break;
        }
    }
    
    Ok(bounds)
}

function parse_method_signature(parser: &mut Parser) -> Result<MethodSignature, ()> {
    let start_span = consume(parser, TokenType::FUNCTION, "Expected 'function'")?;
    let name = consume_identifier(parser, "Expected method name")?;
    
    let generics = if check(parser, TokenType::LESS_THAN) {
        Some(parse_generic_params(parser)?)
    } else {
        None
    };
    
    consume(parser, TokenType::LPAREN, "Expected '('")?;
    let params = parse_parameters(parser)?;
    consume(parser, TokenType::RPAREN, "Expected ')'")?;
    
    let return_type = if match_token(parser, TokenType::ARROW) {
        Some(parse_type_expr(parser)?)
    } else {
        None
    };
    
    let wcet = if match_token(parser, TokenType::WITHIN) {
        Some(parse_wcet_annotation(parser)?)
    } else {
        None
    };
    
    consume(parser, TokenType::SEMICOLON, "Expected ';'")?;
    
    Ok(MethodSignature {
        name,
        generics,
        params,
        return_type,
        is_async: false,
        wcet,
        span: span_union(start_span, parser.previous.span),
    })
}

function parse_associated_type(parser: &mut Parser) -> Result<AssociatedType, ()> {
    let start_span = consume(parser, TokenType::TYPE, "Expected 'type'")?;
    let name = consume_identifier(parser, "Expected associated type name")?;
    
    let bounds = if match_token(parser, TokenType::COLON) {
        parse_trait_bounds(parser)?
    } else {
        Vec::new()
    };
    
    let default = if match_token(parser, TokenType::EQUALS) {
        Some(parse_type_expr(parser)?)
    } else {
        None
    };
    
    consume(parser, TokenType::SEMICOLON, "Expected ';'")?;
    
    Ok(AssociatedType {
        name,
        bounds,
        default,
        span: span_union(start_span, parser.previous.span),
    })
}

function parse_impl(parser: &mut Parser) -> Result<ImplBlock, ()> {
    let start_span = consume(parser, TokenType::IMPL, "Expected 'impl'")?;
    push_context(parser, ParseContext::Impl);
    
    let generics = if check(parser, TokenType::LESS_THAN) {
        Some(parse_generic_params(parser)?)
    } else {
        None
    };
    
    // Check if this is a trait impl
    let (trait_ref, for_type) = if is_trait_impl(parser) {
        let path = parse_path(parser)?;
        let args = if match_token(parser, TokenType::LESS_THAN) {
            parse_generic_args(parser)?
        } else {
            GenericArgs {
                args: Vec::new(),
                span: parser.previous.span,
            }
        };
        
        consume(parser, TokenType::IDENTIFIER, "Expected 'for'")?; // Should check for "for"
        let for_type = parse_type_expr(parser)?;
        
        (Some(TraitRef { path, args: args.args }), for_type)
    } else {
        (None, parse_type_expr(parser)?)
    };
    
    consume(parser, TokenType::LBRACE, "Expected '{'")?;
    
    let mut items = Vec::new();
    while !check(parser, TokenType::RBRACE) {
        items.push(parse_impl_item(parser)?);
    }
    
    consume(parser, TokenType::RBRACE, "Expected '}'")?;
    pop_context(parser);
    
    Ok(ImplBlock {
        generics,
        trait_ref,
        for_type,
        items,
        span: span_union(start_span, parser.previous.span),
    })
}

function parse_impl_item(parser: &mut Parser) -> Result<ImplItem, ()> {
    let visibility = parse_visibility(parser)?;
    
    if check(parser, TokenType::FUNCTION) {
        Ok(ImplItem::Method(parse_function(parser, Vec::new(), visibility)?))
    } else if check(parser, TokenType::TYPE) {
        advance(parser);
        let name = consume_identifier(parser, "Expected associated type name")?;
        consume(parser, TokenType::EQUALS, "Expected '='")?;
        let ty = parse_type_expr(parser)?;
        consume(parser, TokenType::SEMICOLON, "Expected ';'")?;
        Ok(ImplItem::AssociatedType(name, ty))
    } else if check(parser, TokenType::CONST) {
        Ok(ImplItem::Const(parse_const(parser, visibility)?))
    } else {
        error(parser, "Expected impl item");
        Err(())
    }
}

function parse_const(parser: &mut Parser, visibility: Visibility) -> Result<ConstDecl, ()> {
    let start_span = consume(parser, TokenType::CONST, "Expected 'const'")?;
    let name = consume_identifier(parser, "Expected const name")?;
    consume(parser, TokenType::COLON, "Expected ':'")?;
    let ty = parse_type_expr(parser)?;
    consume(parser, TokenType::EQUALS, "Expected '='")?;
    let value = parse_expression(parser)?;
    consume(parser, TokenType::SEMICOLON, "Expected ';'")?;
    
    Ok(ConstDecl {
        name,
        type: ty,
        value,
        visibility,
        span: span_union(start_span, parser.previous.span),
    })
}

function parse_static(parser: &mut Parser, visibility: Visibility) -> Result<StaticDecl, ()> {
    let start_span = consume(parser, TokenType::STATIC, "Expected 'static'")?;
    let is_mut = match_token(parser, TokenType::MUT);
    let name = consume_identifier(parser, "Expected static name")?;
    consume(parser, TokenType::COLON, "Expected ':'")?;
    let ty = parse_type_expr(parser)?;
    consume(parser, TokenType::EQUALS, "Expected '='")?;
    let value = parse_expression(parser)?;
    consume(parser, TokenType::SEMICOLON, "Expected ';'")?;
    
    Ok(StaticDecl {
        name,
        type: ty,
        value,
        is_mut,
        visibility,
        span: span_union(start_span, parser.previous.span),
    })
}

function parse_union_def(parser: &mut Parser) -> Result<UnionDef, ()> {
    let mut fields = Vec::new();
    
    while !check(parser, TokenType::RBRACE) {
        fields.push(parse_field_def(parser)?);
        if !match_token(parser, TokenType::COMMA) && !check(parser, TokenType::RBRACE) {
            error(parser, "Expected ',' or '}'");
        }
    }
    
    consume(parser, TokenType::RBRACE, "Expected '}'")?;
    
    Ok(UnionDef { fields })
}

function parse_function_type(parser: &mut Parser) -> Result<TypeExpr, ()> {
    consume(parser, TokenType::LPAREN, "Expected '('")?;
    
    let mut params = Vec::new();
    if !check(parser, TokenType::RPAREN) {
        loop {
            params.push(parse_type_expr(parser)?);
            if !match_token(parser, TokenType::COMMA) {
                break;
            }
        }
    }
    
    consume(parser, TokenType::RPAREN, "Expected ')'")?;
    consume(parser, TokenType::ARROW, "Expected '->'")?;
    let return_type = parse_type_expr(parser)?;
    
    Ok(TypeExpr::Function(FunctionTypeExpr {
        params,
        return_type: Box::new(return_type),
        is_async: false,
    }))
}

function parse_primitive_type(parser: &mut Parser) -> Result<Option<PrimitiveType>, ()> {
    if !check(parser, TokenType::IDENTIFIER) {
        return Ok(None);
    }
    
    let prim = match parser.current.value.as_str() {
        "bool" => { advance(parser); Some(PrimitiveType::Bool) }
        "i8" => { advance(parser); Some(PrimitiveType::I8) }
        "i16" => { advance(parser); Some(PrimitiveType::I16) }
        "i32" => { advance(parser); Some(PrimitiveType::I32) }
        "i64" => { advance(parser); Some(PrimitiveType::I64) }
        "i128" => { advance(parser); Some(PrimitiveType::I128) }
        "u8" => { advance(parser); Some(PrimitiveType::U8) }
        "u16" => { advance(parser); Some(PrimitiveType::U16) }
        "u32" => { advance(parser); Some(PrimitiveType::U32) }
        "u64" => { advance(parser); Some(PrimitiveType::U64) }
        "u128" => { advance(parser); Some(PrimitiveType::U128) }
        "f32" => { advance(parser); Some(PrimitiveType::F32) }
        "f64" => { advance(parser); Some(PrimitiveType::F64) }
        "char" => { advance(parser); Some(PrimitiveType::Char) }
        "str" => { advance(parser); Some(PrimitiveType::Str) }
        _ => None
    };
    
    Ok(prim)
}

function is_trait_impl(parser: &Parser) -> bool {
    // Look ahead to see if this is a trait impl
    // This is a simplified check - real implementation would be more sophisticated
    let mut i = 0;
    while i < 10 {
        if parser.lexer.source.chars().nth(parser.lexer.position + i) == Some('f') &&
           parser.lexer.source.chars().nth(parser.lexer.position + i + 1) == Some('o') &&
           parser.lexer.source.chars().nth(parser.lexer.position + i + 2) == Some('r') {
            return true;
        }
        i += 1;
    }
    false
}

// Helper functions for parsing
function split_number_suffix(s: &str) -> (String, String) {
    // Find where the numeric part ends and the suffix begins
    let mut numeric_end = s.len();
    for (i, ch) in s.chars().enumerate() {
        if ch.is_alphabetic() && ch != 'e' && ch != 'E' {
            numeric_end = i;
            break;
        }
    }
    
    (s[..numeric_end].to_string(), s[numeric_end..].to_string())
}

function parse_integer(s: &str) -> Result<i128, ()> {
    if s.starts_with("0x") || s.starts_with("0X") {
        // Hexadecimal
        i128::from_str_radix(&s[2..], 16).map_err(|_| ())
    } else if s.starts_with("0o") || s.starts_with("0O") {
        // Octal
        i128::from_str_radix(&s[2..], 8).map_err(|_| ())
    } else if s.starts_with("0b") || s.starts_with("0B") {
        // Binary
        i128::from_str_radix(&s[2..], 2).map_err(|_| ())
    } else {
        // Decimal
        s.parse::<i128>().map_err(|_| ())
    }
}